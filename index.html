<body style="background: white"></body>
<script src="https://cdn.jsdelivr.net/gh/netizenorg/netnet-standard-library/build/nn.min.js"></script>
<script src="https://unpkg.com/tone"></script>
<script src="https://algorithmicmusic.online/js/viz-helpers.js"></script>
<script>
/* global nn, Tone, viz */
const wave = viz.createWaveform()

const folder = 'https://tonejs.github.io/audio/drum-samples/CR78/'
const drumset = new Tone.Players({
  kick: folder + 'kick.mp3',
  snare: folder + 'snare.mp3',
  hihat: folder + 'hihat.mp3'
}).toDestination()
drumset.connect(wave)

const filePath = 'untitled-05-09212014-4_drTFDEs2.mp3'
const player = new Tone.Player(filePath).toDestination()
player.connect(wave)

// we'll create our pattern and cuts (as well as our visuals)
// after we click "randomize" for the first time
let seq
let pattern = []
let cuts = []

Tone.Transport.bpm.value = nn.randomInt(90, 300)
Tone.Transport.loop = true
Tone.Transport.timeSignature = 4
Tone.Transport.loopEnd = '2m'

function toggle () {
  if (Tone.Transport.state === 'stopped') {
    Tone.Transport.start()
    this.content('stop')
  } else {
    Tone.Transport.stop()
    this.content('start')
    player.stop()
  }
}

function updateBPM () {
  Tone.Transport.bpm.value = this.value
}

function updatePatternAndCuts (bar, beat) {
  // play beat (0 or 1)
  pattern[bar][beat] = nn.randomInt(1)
  // random cut selection
  cuts[bar][beat] = {
    offset: nn.random(0, player.buffer.duration),
    duration: 60 / Tone.Transport.bpm.value,
    reverse: Math.random() < 0.5
  }
}

function randomizePattern () {
  // stop and reset
  Tone.Transport.stop()
  toggleBtn.content('start')
  player.stop()
  // loop twice (once for each bar/measure)
  nn.times(2, m => {
    pattern[m] = []
    cuts[m] = []
    // for each measure, loop 4 times to create beats
    nn.times(4, b => updatePatternAndCuts(m, b))
  })
  // choose a random bpm between 90 and 300
  Tone.Transport.bpm.value = nn.randomInt(90, 300)
  // choose a random playback rate between 0.5 and 1.5
  player.playbackRate = nn.random(0.5, 1.5)
  // update UI
  bpmInput.value = Tone.Transport.bpm.value
  if (seq) seq.remove() // remove old sequencer
  seq = viz.createStepSequencer({ // create new one
    sequence: pattern,
    transport: Tone.Transport
  })
}

function play (time) {
  const pos = Tone.Transport.position.split(':').map(Number)
  const bar = pos[0]
  const beat = pos[1]

  const val = pattern[bar][beat]
  const cut = cuts[bar][beat]
  if (val) { // if sequence is checked
    // play back the current "cut"
    player.reverse = cut.reverse
    player.start(time, cut.offset, cut.duration)
    if (cut.reverse) {
    reverseLabel.content('Reverse? Yes')
    document.body.style.background = 'red'

    
  } else {
    reverseLabel.content('Reverse? No')
    document.body.style.background = 'green'
  }
  }

  // backing drum beat; play kick start of every first beat+bar
  if (bar === 0 && beat === 0) drumset.player('kick').start(time)
  // and play hihat on every beat
  drumset.player('hihat').start(time)

  seq.update()
}

new Tone.Loop(play).start()
  
  
//Additions
const reverb = new Tone.Reverb({
  decay: 2,
  wet: 0.3
}).toDestination()
player.chain(reverb)


// UI
nn.create('button')
  .content('randomize')
  .addTo('body')
  .on('click', randomizePattern)

const toggleBtn = nn.create('button')
  .content('start')
  .addTo('body')
  .on('click', toggle)

const bpmInput = nn.create('input')
  .set('type', 'number')
  .set('value', 0)
  .addTo('body')
  .on('change', updateBPM)

const reverseLabel = nn.create('label')
  .content('Reverse? none')
  .addTo('body')

</script>