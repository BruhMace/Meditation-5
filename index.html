<h1>Meditation #5</h1>
<h2>by Maceo</h2>
I was really impressed by the randomized sampling cutup example from the notes. I recently purchased FL Studio, as this class inspired me to experiment with a professional DAW. I’ve found that what I’ve learned in this class, along with my guitar playing, has made features like the piano roll and channel rack relatively easy to pick up, but sampling has been more difficult to grasp. I was surprised by how well the randomized cuts in the class example worked. Even though they were chosen at random, most of them sounded good. That made me really intrigued by the example and motivated me to create my own remix of it.


<p>
In some of my favorite songs that use samples, producers reverse the sample to create a completely new sound. Playboi Carti’s Fell in Luv, which samples Purity Ring’s Grandloves, remains my favorite reversed sample of all time. That inspired me to experiment by having half of the cutups play in reverse. When I implemented this, I thought I could hear the reversals happening, but since some were subtle, I added a message that would tell me whether the sample was reversed. I also made the background change color with red for reversed and green for normalto visualize it. Finally, I added some reverb to give the samples and drums a bit more oomph. Overall, this meditation gave me a completely new perspective on sampling. I realized it’s not always about finding the perfect chops and that you can make sampling sound good with almost anything.
<p>
</p>

<body style="background: white"></body>
<script src="https://cdn.jsdelivr.net/gh/netizenorg/netnet-standard-library/build/nn.min.js"></script>
<script src="https://unpkg.com/tone"></script>
<script src="https://algorithmicmusic.online/js/viz-helpers.js"></script>
<script>
/* global nn, Tone, viz */
const wave = viz.createWaveform()

const folder = 'https://tonejs.github.io/audio/drum-samples/CR78/'
const drumset = new Tone.Players({
  kick: folder + 'kick.mp3',
  snare: folder + 'snare.mp3',
  hihat: folder + 'hihat.mp3'
}).toDestination()
drumset.connect(wave)

const filePath = 'untitled-05-09212014-4_drTFDEs2.mp3'
const player = new Tone.Player(filePath).toDestination()
player.connect(wave)

// we'll create our pattern and cuts (as well as our visuals)
// after we click "randomize" for the first time
let seq
let pattern = []
let cuts = []

Tone.Transport.bpm.value = nn.randomInt(90, 300)
Tone.Transport.loop = true
Tone.Transport.timeSignature = 4
Tone.Transport.loopEnd = '2m'

function toggle () {
  if (Tone.Transport.state === 'stopped') {
    Tone.Transport.start()
    this.content('stop')
  } else {
    Tone.Transport.stop()
    this.content('start')
    player.stop()
  }
}

function updateBPM () {
  Tone.Transport.bpm.value = this.value
}

function updatePatternAndCuts (bar, beat) {
  // play beat (0 or 1)
  pattern[bar][beat] = nn.randomInt(1)
  // random cut selection
  cuts[bar][beat] = {
    offset: nn.random(0, player.buffer.duration),
    duration: 60 / Tone.Transport.bpm.value,
    reverse: Math.random() < 0.5
  }
}

function randomizePattern () {
  // stop and reset
  Tone.Transport.stop()
  toggleBtn.content('start')
  player.stop()
  // loop twice (once for each bar/measure)
  nn.times(2, m => {
    pattern[m] = []
    cuts[m] = []
    // for each measure, loop 4 times to create beats
    nn.times(4, b => updatePatternAndCuts(m, b))
  })
  // choose a random bpm between 90 and 300
  Tone.Transport.bpm.value = nn.randomInt(90, 300)
  // choose a random playback rate between 0.5 and 1.5
  player.playbackRate = nn.random(0.5, 1.5)
  // update UI
  bpmInput.value = Tone.Transport.bpm.value
  if (seq) seq.remove() // remove old sequencer
  seq = viz.createStepSequencer({ // create new one
    sequence: pattern,
    transport: Tone.Transport
  })
}

function play (time) {
  const pos = Tone.Transport.position.split(':').map(Number)
  const bar = pos[0]
  const beat = pos[1]

  const val = pattern[bar][beat]
  const cut = cuts[bar][beat]
  if (val) { 
    player.reverse = cut.reverse
    player.start(time, cut.offset, cut.duration)
    if (cut.reverse) {
    reverseLabel.content('Reverse? Yes')
    document.body.style.background = 'red'
  } else {
    reverseLabel.content('Reverse? No')
    document.body.style.background = 'green'
  }
  }

  // backing drum beat; play kick start of every first beat+bar
  if (bar === 0 && beat === 0) drumset.player('kick').start(time)
  // and play hihat on every beat
  drumset.player('hihat').start(time)

  seq.update()
}

new Tone.Loop(play).start()
  
  
//Effects
const reverb = new Tone.Reverb({
  decay: 2,
  wet: 0.3
}).toDestination()
player.chain(reverb)


// UI
nn.create('button')
  .content('randomize')
  .addTo('body')
  .on('click', randomizePattern)

const toggleBtn = nn.create('button')
  .content('start')
  .addTo('body')
  .on('click', toggle)

const bpmInput = nn.create('input')
  .set('type', 'number')
  .set('value', 0)
  .addTo('body')
  .on('change', updateBPM)

const reverseLabel = nn.create('label')
  .content('Reverse? none')
  .addTo('body')

</script>